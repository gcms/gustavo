package br.ufg.inf.compiler.syntatic;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import br.ufg.inf.compiler.main.SetupException;

public class Grammar {
	/** Símbolo inicial da gramática. */
	private NonTerminal startSymbol;

	/** Produções da gramática. */
	private Set<Production> productions;

	/**
	 * Cria uma gramática não inicializada.
	 */
	public Grammar() {
		this(null);
	}

	/**
	 * Determina o símbolo inicial da gramática.
	 * 
	 * @param startSymbol
	 *            símbolo inicial
	 */
	public void setStartSymbol(NonTerminal startSymbol) {
		this.startSymbol = startSymbol;
	}

	/**
	 * Cria uma nova gramática.
	 * 
	 * @param startSymbol
	 *            símbolo inicial
	 */
	public Grammar(NonTerminal startSymbol) {
		this.startSymbol = startSymbol;
		productions = new HashSet<Production>();
	}

	/**
	 * Retorna produções geradas a partir do não terminal definido.
	 * 
	 * @param var
	 *            não terminal especificado
	 * @return
	 */
	public Set<Production> getProductionsBySymbol(NonTerminal var) {
		Set<Production> result = new HashSet<Production>();

		for (Production p : productions) {
			if (p.getVariable().equals(var)) {
				result.add(p);
			}
		}

		return result;
	}

	/**
	 * Cria um novo não terminal associado a esta gramática.
	 * 
	 * @return novo não terminal criado
	 */
	public NonTerminal createNonTerminal() {
		return new NonTerminal();
	}

	/**
	 * Cria uma cópia dessa gramática, útil pra criar transformações sobre a
	 * gramática, sem alterá-la.
	 * 
	 * @return cópia cesta gramática
	 */
	public Object clone() {
		Grammar g = new Grammar();
		g.productions = new HashSet<Production>(productions);
		g.startSymbol = startSymbol;

		return g;
	}

	/**
	 * Obtém uma gramática que gera a mesma linguagem desta, porém sem regras
	 * EPSILON.
	 * 
	 * @return gramática correspondente sem regras EPSILON
	 */
	public Grammar getNoEpsilonGrammar() {
		Grammar g = (Grammar) clone();

		g.setNoEpsilon();

		return g;
	}

	/**
	 * Remove ciclos da gramática.
	 * 
	 */
	public void setNoCycle() {
		for (Iterator<Production> it = productions.iterator(); it.hasNext(); /* */) {
			Production p = it.next();

			if (p.isCycle())
				it.remove();
		}
	}

	/**
	 * Retorna o conjunto de variaveis EPSILON. É utilizado na remoção de regras
	 * EPSILON.
	 * 
	 * @return conjunto de variaveis EPSILON
	 */
	private Set<NonTerminal> findEpsilonVariables() {
		Set<NonTerminal> result = new HashSet<NonTerminal>();
		int lastSize;

		for (Production p : productions) {
			if (p.derivesEpsilon()) { /* derives Epsilon, so is an Epsilon-var */
				result.add(p.getVariable());
			}
		}

		do {
			lastSize = result.size();

			for (Production p : productions) {
				/*
				 * if symbols in p is a subset of the Epsilon-vars. It's
				 * generation symbol is also an Epsilon-var
				 */
				if (p.symbolsIsSubsetOf(new HashSet<Symbol>(result))) {
					result.add(p.getVariable());
				}
			}
		} while (lastSize != result.size());

		return result;
	}

	/**
	 * Remove recursão no símbol inicial.
	 * 
	 */
	private void removeRecurStartSymbol() {
		for (Production p : getProductionsBySymbol(startSymbol)) {
			if (p.isRecursive()) {
				Production startProduction = new Production(
						createNonTerminal(), new Symbol[] { startSymbol });
				startSymbol = startProduction.getVariable();
				productions.add(startProduction);
				break;
			}
		}

	}

	/**
	 * Remove variáveis EPSILON da gramática, exceto do símbolo inicial.
	 * 
	 */
	public void setNoEpsilon() {
		/* Remove recursion on start symbol */
		removeRecurStartSymbol();

		/* find the Epsilon-vars */
		Set<NonTerminal> eVars = findEpsilonVariables();

		if (eVars.size() == 1 && eVars.iterator().next().equals(startSymbol))
			return;

		for (NonTerminal e : eVars) {
			/* Remove productions that derive an Epsilon-var directly */
			for (Iterator<Production> it = productions.iterator(); it.hasNext(); /* */) {
				Production p = it.next();
				if (p.getVariable().equals(e) && p.derivesEpsilon()) {
					it.remove();
				}
			}

			/*
			 * Productions to be added, generated by removing the variable an
			 * Epsilon-var from the productions.
			 */
			Set<Production> toAdd = new HashSet<Production>();

			for (Production p : productions) {
				for (Production q : p.remove(e)) {
					toAdd.add(q);
				}
			}

			productions.addAll(toAdd);
		}

		/*
		 * If we have Epsilon-vars we have to add an Epsilon production to the
		 * start symbol
		 */
		if (eVars.size() > 0)
			productions.add(new Production(startSymbol, new Symbol[] {}));
	}

	/**
	 * Obtém os não terminais desa gramática.
	 * 
	 * @return conjunto de não terminais desta gramática
	 */
	Set<NonTerminal> getNonTerminals() {
		Set<NonTerminal> result = new HashSet<NonTerminal>();
		for (Production p : productions) {

			result.add(p.getVariable());
		}

		return result;
	}

	/**
	 * Elimina recursão a esquerda.
	 */
	public void setNoLeftRecursion() {
		setNoEpsilon();
		setNoCycle();

		NonTerminal[] vars = getNonTerminals().toArray(new NonTerminal[] {});

		for (int i = 0; i < vars.length; i++) {
			for (int j = 0; j < i; j++) {
				for (Iterator<Production> it = productions.iterator(); it
						.hasNext();) {
					Production p = it.next();

					if (p.getVariable().equals(vars[i])
							&& p.getSentence().size() > 0
							&& p.getSentence().first().equals(vars[j])) {
						/* Ai -> Aj y */

						for (Production d : getProductionsBySymbol(vars[j])) {
							Sentence delta = d.getSentence();
							delta.addAll(p.getSentence().subSentence(1, -1));
						}

						it.remove();
					}
				}
			}

			for (Iterator<Production> it = getProductionsBySymbol(vars[i])
					.iterator(); it.hasNext();) {
				Production p = it.next();

				if (p.isLeftRecursive()) {

					it.remove();
				}
			}
		}
	}

	/**
	 * Obtém uma representação textual da gramática.
	 * 
	 * @return uma string representando a gramática
	 */
	public String toString() {
		StringBuilder builder = new StringBuilder();

		for (Production p : productions) {
			builder.append(p.getVariable().equals(startSymbol) ? "-> " : "   ");
			builder.append(p.toString() + "\n");
		}

		return builder.toString();
	}

	/**
	 * Adiciona uma produção.
	 * 
	 * @param nonTerm
	 *            lado esquerdo
	 * @param sentence
	 *            lado direito
	 */
	public void addProduction(NonTerminal nonTerm, Sentence sentence) {
		productions.add(new Production(nonTerm, sentence));
	}

	/**
	 * Adiciona uma produção.
	 * 
	 * @param nonTerm
	 *            lado esquerdo
	 * @param symbols
	 *            lado direito
	 */
	public void addProduction(NonTerminal nonTerm, Symbol[] symbols) {
		productions.add(new Production(nonTerm, symbols));
	}

	/**
	 * Adiciona uma produção usando uma convenção de strings como representação.
	 * 
	 * @see Sentence
	 * 
	 * @param nonTerm
	 *            lado esquerdo
	 * @param sentence
	 *            lado direito
	 */
	public void addProduction(char nonTerm, String sentence) {
		if (!Character.isUpperCase(nonTerm))
			throw new SetupException("Sentence: Não terminal lowercase.");

		addProduction(new NonTerminal(Character.toString(nonTerm)),
				new Sentence(sentence));
	}

	/**
	 * Previamente usado para testes.
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		NonTerminal A = new NonTerminal("A");
		NonTerminal B = new NonTerminal("B");
		NonTerminal C = new NonTerminal("C");
		NonTerminal S = new NonTerminal("S");

		Terminal a = new Terminal("a");
		Terminal b = new Terminal("b");
		Terminal c = new Terminal("c");

		Grammar g = new Grammar();
		g.startSymbol = S;

		g.productions.add(new Production(S, new Symbol[] { A, C, A }));

		g.productions.add(new Production(A, new Symbol[] { a, A, a }));
		g.productions.add(new Production(A, new Symbol[] { B }));
		g.productions.add(new Production(A, new Symbol[] { C }));

		g.productions.add(new Production(B, new Symbol[] { b, B }));
		g.productions.add(new Production(B, new Symbol[] { b }));

		g.productions.add(new Production(C, new Symbol[] { c, C }));
		g.productions.add(new Production(C, new Symbol[] {}));

		System.out.println(g);

		g.removeRecurStartSymbol();
		System.out.println(g);

		System.out.println("Epsilon");
		System.out.println(g.findEpsilonVariables());

		System.out.println("Removing C");
		g.setNoEpsilon();
		System.out.println(g.findEpsilonVariables());
		System.out.println(g);
	}

	/**
	 * Obtém as produções desta gramática
	 * 
	 * @return produções
	 */
	public Set<Production> getProductions() {
		return productions;
	}

	/**
	 * Obtém o símbolo inicial dessa gramática.
	 * 
	 * @return símbolo inicial
	 */
	public NonTerminal getStartSymbol() {
		return startSymbol;
	}

	public Set<Production> getProductionsWith(NonTerminal v) {
		Set<Production> result = new HashSet<Production>();
		for (Production p : getProductions()) {
			if (p.getSentence().contains(v))
				result.add(p);
		}
		return result;
	}
}
